test0: {
  function f() {
    console.error(new Error("The dom is gone"));
    return;
  }
}
test1: {
  function f() {
    e.push(n.slice(0, s).join(""));
    return;
  }
}
test2: {
  function f() {
    window.gui.openPopup({
      title: h("tablet.window.shop.title"),
      message: h("ui.popup.accessDenied.serviceUnavailable")
    });
    return;
  }
}
test3: {
  function f() {
    e.cancelSlide();
    return;
  }
}
test4: {
  function f() {
    e.cancelSlide();
    return;
  }
}
test5: {
  function f() {
    P = x;
    return;
  }
}
test6: {
  function f() {
    this.myWindow.windowManager.close(this.myWindow.id);
    return;
  }
}
test7: {
  function f() {
    delete this.domListeners[i];
    return;
  }
}
test8: {
  function f() {
    M = !0;
    return;
  }
}
test9: {
  function f() {
    o();
    return;
  }
}
test10: {
  function f() {
    this.gain.value = e;
    return;
  }
}
test11: {
  function f() {
    this.source.playbackRate.value = t;
    return;
  }
}
test12: {
  function f() {
    this._playTriggered = Date.now();
    return;
  }
}
test13: {
  function f() {
    c.error("ankAnalytics checkModel: " + e + " is missing from the models");
    return;
  }
}
test14: {
  function f() {
    console.error(new Error("IndexedDB id to get in object store: " + e + ", is invalid: " + t));
    return;
  }
}
test15: {
  function f() {
    console.error(new Error("IndexedDB id to get in object store: " + e + ", is invalid: " + t));
    return;
  }
}
test16: {
  function f() {
    console.error("IndexedDB object to put in object store: " + e + ", is invalid: " + t);
    return;
  }
}
test17: {
  function f() {
    console.error("IndexedDB object to put in object store: " + e + ", is invalid: " + t);
    return;
  }
}
test18: {
  function f() {
    t(new Error("IndexedDB request failed: disk cache not yet initialized"));
    return;
  }
}
test19: {
  function f() {
    i(new Error("IndexedDB putAll operation called but cache completion is not set up"));
    return;
  }
}
test20: {
  function f() {
    e.DEBUG && console.log("Looks like the request set is already running", this.mode);
    return;
  }
}
test21: {
  function f() {
    M.error("sendKPIEvent: Error on event id: " + t + ", error: " + e);
    return;
  }
}
test22: {
  function f() {
    e._isValid = !1;
    return;
  }
}
test23: {
  function f() {
    e._isValid = !1;
    return;
  }
}
test24: {
  function f() {
    e._isValid = !1;
    return;
  }
}
test25: {
  function f() {
    e._isValid = !1;
    return;
  }
}
test26: {
  function f() {
    dt(e);
    return;
  }
}
test27: {
  function f() {
    gt(e);
    return;
  }
}
test28: {
  function f() {
    this._nextTimeout = setTimeout(function () {
      t._nextTimeout = 0, t._next(e);
    }, o);
    return;
  }
}
test29: {
  function f() {
    this._callbackAndLeave(o, e);
    return;
  }
}
test30: {
  function f() {
    console.log("[DOFUS PROXY]     send: %c" + e.data.data.type, "background-color: #6DF;", e.data.data.data);
    return;
  }
}
test31: {
  function f() {
    i = !1;
    return;
  }
}
test32: {
  function f() {
    I.openState && e();
    return;
  }
}
test33: {
  function f() {
    C ? u(n, C.ownerName, C.houseId, C._displayedName) : u(n, C.ownerName, C.houseId);
    return;
  }
}
test34: {
  function f() {
    console.warn("Fighter information could not be extracted from this message type: " + e._messageType);
    return;
  }
}
test35: {
  function f() {
    3 === e && (this.text = t.toString());
    return;
  }
}
test36: {
  function f() {
    2 === e && (this.value = t);
    return;
  }
}
test37: {
  function f() {
    0 === e ? this.min = t : 1 === e && (this.max = t);
    return;
  }
}
test38: {
  function f() {
    0 === e ? this.diceNum = t : 1 === e ? this.diceSide = t : 2 === e && (this.value = t);
    return;
  }
}
test39: {
  function f() {
    0 === e ? this.year = t : 1 === e ? (this.month = t.substr(0, 2), this.day = t.substr(2, 2)) : 2 === e ? (this.hour = t.substr(0, 2), this.minute = t.substr(2, 2)) : 3 === e ? this.month = t : 4 === e && (this.day = t);
    return;
  }
}
test40: {
  function f() {
    0 === e ? this.days = t : 1 === e ? this.hours = t : 2 === e && (this.minutes = t);
    return;
  }
}
test41: {
  function f() {
    0 === e ? this.monsterFamilyId = t : 2 === e && (this.monsterCount = t);
    return;
  }
}
test42: {
  function f() {
    0 === e && (this.monsterFamilyId = t);
    return;
  }
}
test43: {
  function f() {
    console.error("Trying to apply a stats buff on non-existing fighter " + this.targetId);
    return;
  }
}
test44: {
  function f() {
    "summonableCreaturesBoost" === this.statName ? i.fightManager.emit("updateSpellsAvailability") : "range" === this.statName && t.foreground.refreshSpellRange();
    return;
  }
}
test45: {
  function f() {
    this.renderingRequired = !0;
    return;
  }
}
test46: {
  function f() {
    window.setTimeout(function () {
      if (s.resize(), !e.rootElement || 0 === e.width || 0 === e.height) return console.warn("[CharacterDisplay._render] Character display size must be greater than zero.");
    }, 0);
    return;
  }
}
test47: {
  function f() {
    console.error(new Error("Entity animation frame is empty, template:" + l + ", animation:" + c));
    return;
  }
}
test48: {
  function f() {
    console.warn("[WebGLRenderer.updateVertexBuffer] No buffer loaded for", e);
    return;
  }
}
test49: {
  function f() {
    console.warn("[WebGLRenderer.drawSpriteBatch] No buffer loaded for", e);
    return;
  }
}
test50: {
  function f() {
    console.warn("[WebGLRenderer.drawSpriteSubBatch] No buffer loaded for", e);
    return;
  }
}
test51: {
  function f() {
    console.warn("[WebGLRenderer._drawSubBatch] Texture not loaded:", i.id);
    return;
  }
}
test52: {
  function f() {
    this.spellShortcuts[t] = e;
    return;
  }
}
test53: {
  function f() {
    console.error(new Error("touch1 is null, touchCount: " + s.touchCount + " x: " + s.x + " y: " + s.y));
    return;
  }
}
test54: {
  function f() {
    a.requestInteractionHandle("TRANSFORM", e) ? (y = !0, e.isTransforming = !0, e.emit("transformStart", s, f)) : e.cancelTransform();
    return;
  }
}
test55: {
  function f() {
    this.closeRequest = !0;
    return;
  }
}
test56: {
  function f() {
    this.requestRefresh = !0;
    return;
  }
}
test57: {
  function f() {
    this.initiated = !1;
    return;
  }
}
test58: {
  function f() {
    this.initiated = !1;
    return;
  }
}
test59: {
  function f() {
    this._execEvent("flick");
    return;
  }
}
test60: {
  function f() {
    this.goToPage(o, a);
    return;
  }
}
test61: {
  function f() {
    h.emit("entityAdded", g.taxCollector, i);
    return;
  }
}
test62: {
  function f() {
    delete this.prism;
    return;
  }
}
test63: {
  function f() {
    y.useObject(e);
    return;
  }
}
test64: {
  function f() {
    this.hide();
    return;
  }
}
test65: {
  function f() {
    a.replaceClassNames([o], ["deadLink"]);
    return;
  }
}
test66: {
  function f() {
    console.error(new Error("Chat wrong object"));
    return;
  }
}
test67: {
  function f() {
    this.displayMode = e;
    return;
  }
}
test68: {
  function f() {
    this._setInput("");
    return;
  }
}
test69: {
  function f() {
    this._delayedPois.push(e);
    return;
  }
}
test70: {
  function f() {
    console.error(new Error("GPS: Cannot find the quest: " + n + ", objectiveId: " + i));
    return;
  }
}
test71: {
  function f() {
    this.highlightRow(t);
    return;
  }
}
test72: {
  function f() {
    console.warn("Invalid index, row does not exist or empty!");
    return;
  }
}
test73: {
  function f() {
    v.showNotification(e.join("\r\n"), this);
    return;
  }
}
test74: {
  function f() {
    console.error("MenuBar._addNotificationIcon: undefined iconName with notificationIcon", t);
    return;
  }
}
test75: {
  function f() {
    console.error("MenuBar._addNotificationIcon: undefined notificationIcon on iconName", e);
    return;
  }
}
test76: {
  function f() {
    console.error("MenuBar._removeNotificationIcon: undefined iconName with notificationIcon:", t);
    return;
  }
}
test77: {
  function f() {
    console.error("MenuBar._removeNotificationIcon: undefined notificationIcon on iconName:", e);
    return;
  }
}
test78: {
  function f() {
    console.warn("emitCharacteristicsUpdate: the character does not exist");
    return;
  }
}
test79: {
  function f() {
    console.warn("setCharacteristics: the character does not exist");
    return;
  }
}
test80: {
  function f() {
    console.warn("setCharacteristic: the character does not exist");
    return;
  }
}
test81: {
  function f() {
    delete this._playersMultiCraftSkillById[i];
    return;
  }
}
test82: {
  function f() {
    console.error(new Error("QuestStepValidatedMessage: quest gone for " + t.questId));
    return;
  }
}
test83: {
  function f() {
    this._selectedSlot = null;
    return;
  }
}
test84: {
  function f() {
    e.data.alive && i.fightManager.currentFighterId === n && (i.fightManager.castSpell(t, e.data.disposition.cellId, i.playerData.characters.controlledCharacterId), window.isoEngine.clearSpellDisplay(), i.shortcutBar.deselectCurrentSlot());
    return;
  }
}
test85: {
  function f() {
    n.addBuff(e);
    return;
  }
}
test86: {
  function f() {
    console.warn("Trying to update a non-existing buff.");
    return;
  }
}
test87: {
  function f() {
    this.hide();
    return;
  }
}
test88: {
  function f() {
    this._markerDom && this.remove();
    return;
  }
}
test89: {
  function f() {
    this._onFinished();
    return;
  }
}
test90: {
  function f() {
    this.slotToShow = e;
    return;
  }
}
test91: {
  function f() {
    this._displayPage(~~(n / t.slotsPerPage));
    return;
  }
}
test92: {
  function f() {
    console.error(new Error("No slot with item UID " + t));
    return;
  }
}
test93: {
  function f() {
    this.selectedSlot && (this.selectedSlot.unselect(), this.selectedSlot = null);
    return;
  }
}
test94: {
  function f() {
    console.error(new Error("PresetBox#setDeleteContextMenu: selectedPreset is missing for pos " + n + " mountModel " + o + " type " + a));
    return;
  }
}
test95: {
  function f() {
    window.actorManager.userActor.testAnimation(r, function (e) {
      t.logMessage(e, "Debug");
    });
    return;
  }
}
test96: {
  function f() {
    this.filterButtons.splice(t, 1);
    return;
  }
}
test97: {
  function f() {
    t.disable();
    return;
  }
}
test98: {
  function f() {
    x();
    return;
  }
}
test99: {
  function f() {
    m.tap();
    return;
  }
}
test100: {
  function f() {
    s.spinner.hide();
    return;
  }
}
test101: {
  function f() {
    s.spinner.hide();
    return;
  }
}
test102: {
  function f() {
    this.searching = !1;
    return;
  }
}
test103: {
  function f() {
    this._updateQuestList();
    return;
  }
}
test104: {
  function f() {
    console.error(new Error("CategoryElement cannot be found to add questId " + e));
    return;
  }
}
test105: {
  function f() {
    t ? g.enableDrag(i) : g.disableDrag(i);
    return;
  }
}
test106: {
  function f() {
    this.tabIcon.setStyle("backgroundImage", r);
    return;
  }
}
test107: {
  function f() {
    this.lastJobIdRequested = e;
    return;
  }
}
test108: {
  function f() {
    this.bonusTable.addRow({
      description: h("ui.set.secretBonus")
    });
    return;
  }
}
test109: {
  function f() {
    L.openPopup({
      title: d("ui.common.error"),
      message: d("ui.nickname.invalid")
    });
    return;
  }
}
test110: {
  function f() {
    console.error(new Error("centerToPosition no coords"));
    return;
  }
}
test111: {
  function f() {
    console.error(new Error("centerToPosition no pos: " + e.constructor.name));
    return;
  }
}
test112: {
  function f() {
    this._clearChunks();
    return;
  }
}
test113: {
  function f() {
    console.error("addIcon: An icon of id", t, "already exists.");
    return;
  }
}
test114: {
  function f() {
    console.error(new Error("[IconBatch.addIconToVertexBuffer] Icon cluster not present in ordered list"));
    return;
  }
}
test115: {
  function f() {
    console.error(new Error("[IconBatch.addIconToVertexBuffer] Icon not present in its cluster"));
    return;
  }
}
test116: {
  function f() {
    console.warn("[IconBatch.addIconToVertexBuffer] Trying to add an icon already present in the vertex buffer");
    return;
  }
}
test117: {
  function f() {
    console.error(new Error("[IconBatch.updateIconPosition] Given icon is not present in the vertex buffer"));
    return;
  }
}
test118: {
  function f() {
    this._subareaToShow = e;
    return;
  }
}
test119: {
  function f() {
    this._createAll(function (i) {
      if (i) {
        return console.error("characterCreation: initialize error", i);
      }
      t._initialize(e);
      t._loadHeadImages();
      return;
    });
    return;
  }
}
test120: {
  function f() {
    k = !0;
    return;
  }
}
test121: {
  function f() {
    this._needsResize = !0;
    return;
  }
}
test122: {
  function f() {
    t.showNoResult(this.categoriesName[this.openedCategory], ~~e.categoryId);
    return;
  }
}
test123: {
  function f() {
    console.error("Loaded static achievement data error", e);
    return;
  }
}
test124: {
  function f() {
    console.error("Failed to get items", e);
    return;
  }
}
test125: {
  function f() {
    t.showNoResult(a("ui.dailyQuest.premiumReroll"), ~~e.categoryId);
    return;
  }
}
test126: {
  function f() {
    e._handleError();
    return;
  }
}
test127: {
  function f() {
    u.open("legalAgreement", o);
    return;
  }
}
test128: {
  function f() {
    this._logger.error(new Error("Product id: " + e.id + " is " + e.state));
    return;
  }
}
test129: {
  function f() {
    this._logger.error(new Error("Product id: " + e.id + " has no micro prices, state: " + e.state));
    return;
  }
}
test130: {
  function f() {
    this._logger.error(new Error("Product id: " + e.id + " has no prices, state: " + e.state));
    return;
  }
}
test131: {
  function f() {
    (d || u) && e.preventDefault();
    return;
  }
}
test132: {
  function f() {
    window.gui.chat.logMsg(r("tablet.inventoryFullCannotMove"));
    return;
  }
}
test133: {
  function f() {
    this.once("ready", function () {
      t.mapId === i && t.updateObstacles(e);
    });
    return;
  }
}
test134: {
  function f() {
    console.error(new Error("map is null, isReady is " + this.isReady));
    return;
  }
}
test135: {
  function f() {
    console.error("[IsoEngine.addPingPicto] No base for type", c);
    return;
  }
}
test136: {
  function f() {
    console.error("[Zone] It is not possible to create a zone without colors and outline");
    return;
  }
}
test137: {
  function f() {
    console.error("openPlayerContextualMenu was called on non player actor", this.actorId);
    return;
  }
}
test138: {
  function f() {
    console.error("openNpcContextualMenu was called on non npc actor", this.actorId);
    return;
  }
}
test139: {
  function f() {
    window.gui.openContextualMenu("fightSwap", a, l);
    return;
  }
}
test140: {
  function f() {
    b.push(e);
    return;
  }
}
test141: {
  function f() {
    console.warn("Source actor does not exist");
    return;
  }
}
test142: {
  function f() {
    t._doNotProcess = !0;
    return;
  }
}
test143: {
  function f() {
    console.error(new Error("ActionQueue.staticContent.getAllDataMap: " + e));
    return;
  }
}
test144: {
  function f() {
    this.clear();
    return;
  }
}
test145: {
  function f() {
    this.interactiveMessageStack.push(e);
    return;
  }
}
test146: {
  function f() {
    i && t.actionQueue.dequeue(e.elemId);
    return;
  }
}
test147: {
  function f() {
    p && window.foreground.showBorderArrow(r, a, s);
    return;
  }
}
test148: {
  function f() {
    0 === i.dist && m[0].tap(e, t, l.camera);
    return;
  }
}
test149: {
  function f() {
    window.gui.fightManager.isFighterOnUsersTeam(a.actorId) && a.tap(e, t, this.mapRenderer.camera);
    return;
  }
}
test150: {
  function f() {
    this._resetSpellEffectLayer();
    return;
  }
}
test151: {
  function f() {
    this._resetSpellEffectLayer();
    return;
  }
}
test152: {
  function f() {
    t.staticAnim();
    return;
  }
}
